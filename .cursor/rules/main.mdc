---
alwaysApply: true
---

# Deco MCP Template Development Guide

## Project Overview

This is a **Deco MCP (Model Context Protocol) server** template with a **React + Tailwind CSS frontend**. It provides a full-stack development environment where:
- The `/server` folder contains the MCP server (Cloudflare Workers + Deco runtime)
- The `/view` folder contains the React frontend (Vite + Tailwind CSS)
- The server serves both MCP endpoints AND the built frontend assets

## Project Structure

```
react-tailwind-view/
├── package.json          # Root workspace with dev/gen/deploy scripts
├── server/               # MCP Server (Cloudflare Workers + Deco)
│   ├── main.ts          # Main server entry point
│   ├── deco.gen.ts      # Generated types for integrations
│   ├── wrangler.toml    # Cloudflare Workers config
│   └── package.json     # Server dependencies
└── view/                # React Frontend (Vite + Tailwind)
    ├── src/
    │   ├── main.tsx     # React app entry point
    │   ├── lib/rpc.ts   # RPC client for server communication
    │   ├── hooks/       # TanStack Query hooks for RPC calls
    │   ├── routes/      # React Router routes
    │   └── components/  # UI components
    ├── package.json     # Frontend dependencies
    └── vite.config.ts   # Vite configuration
```

## Development Workflow

### Root Commands (npm workspace)
- `npm run dev` - **Primary development command**
  - Starts frontend build in watch mode
  - Starts MCP server on port 8787
  - Server serves both API endpoints + frontend assets
  - Hot reload for both frontend and backend
  
- `npm run gen` - **Type generation**
  - Generates TypeScript types for deco integrations
  - Creates `server/deco.gen.ts` with typed RPC interfaces
  - Run this after adding new integrations in deco.chat

- `npm run gen:self` - **Self-type generation for your own tools**
  - Generates TypeScript types for your own server's tools and workflows
  - Requires the server to be running (`npm run dev`)
  - Copy the development URL from server logs (e.g., "https://localhost-48d64e92.deco.host")
  - Add /mcp to the path. So, for the URL https://localhost-48d64e92.deco.host you should set DECO_SELF_URL as https://localhost-48d64e92.deco.host/mcp.
  - Run: `DECO_SELF_URL=<your-dev-url> npm run gen:self`
  - Creates typed RPC interfaces for your own tools/workflows
  - Run this after adding new tools or workflows to your server

- `npm run deploy` - **Production deployment**
  - Builds frontend for production
  - Deploys to Cloudflare Workers
  - Makes app available at public URL

### Server Architecture (`/server`)

**Key Files:**
- `main.ts` - Main server with tools, workflows, and asset serving
- `deco.gen.ts` - Generated types for integrations (auto-generated)
- `wrangler.toml` - Cloudflare Workers config with asset binding

**Server Pattern:**
```typescript
// server/main.ts structure
import { withRuntime } from "@deco/workers-runtime";

// 1. Define tools (functions the MCP can call)
const createMyTool = (env: Env) => createTool({
  id: "MY_TOOL",
  description: "Tool description",
  inputSchema: z.object({ /* input schema */ }),
  outputSchema: z.object({ /* output schema */ }),
  execute: async ({ context }) => {
    // Tool logic here
    return { /* result */ };
  },
});

// 2. Define workflows (multi-step processes)
const createMyWorkflow = (env: Env) => {
  const step = createStepFromTool(createMyTool(env));
  return createWorkflow({
    id: "MY_WORKFLOW",
    inputSchema: z.object({ /* input */ }),
    outputSchema: z.object({ /* output */ }),
  }).then(step).commit();
};

// 3. Setup runtime with fallback to serve frontend
const { Workflow, ...runtime } = withRuntime<Env>({
  workflows: [createMyWorkflow],
  tools: [createMyTool],
  fetch: fallbackToView("/"), // Serves frontend assets
});

export { Workflow };
export default runtime;
```

### Frontend Architecture (`/view`)

**Key Files:**
- `src/main.tsx` - React app entry with TanStack Router setup
- `src/lib/rpc.ts` - RPC client for server communication
- `src/routes/` - TanStack Router routes
- `src/components/` - UI components with Tailwind CSS

**Frontend-to-Server Communication:**
```typescript
// view/src/lib/rpc.ts
import { createClient } from "@deco/workers-runtime/client";
import type { Env } from "../../../server/deco.gen.ts";

type SelfMCP = Env["SELF"];
export const client = createClient<SelfMCP>();
```

**Best Practice: Use TanStack Query Hooks for RPC Calls**

**❌ Avoid calling RPC client directly in components:**
```typescript
// DON'T DO THIS - Direct RPC calls in components
function MyComponent() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    client.MY_TOOL({ name: "example" }).then(setData);
  }, []);
  
  return <div>{data?.result}</div>;
}
```

**✅ Recommended: Wrap RPC calls with TanStack Query hooks:**
```typescript
// view/src/hooks/useMyTool.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { client } from "../lib/rpc";

// For read operations - use useQuery
export const useMyTool = (input: { name: string }) => {
  return useQuery({
    queryKey: ["myTool", input],
    queryFn: () => client.MY_TOOL(input),
    enabled: !!input.name, // Only run when input is valid
  });
};

// For write operations - use useMutation
export const useMyToolMutation = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (input: { name: string }) => client.MY_TOOL(input),
    onSuccess: () => {
      // Invalidate related queries after successful mutation
      queryClient.invalidateQueries({ queryKey: ["myTool"] });
    },
  });
};

// For workflows - typically use useMutation
export const useStartMyWorkflow = () => {
  return useMutation({
    mutationFn: (input: { name: string }) => client.START_MY_WORKFLOW(input),
  });
};

// Usage in components:
function MyComponent() {
  const { data, isLoading, error } = useMyTool({ name: "example" });
  const myToolMutation = useMyToolMutation();
  const startWorkflow = useStartMyWorkflow();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <p>Result: {data?.result}</p>
      <button 
        onClick={() => myToolMutation.mutate({ name: "new-example" })}
        disabled={myToolMutation.isPending}
      >
        {myToolMutation.isPending ? "Running..." : "Run Tool"}
      </button>
      <button 
        onClick={() => startWorkflow.mutate({ name: "workflow-input" })}
        disabled={startWorkflow.isPending}
      >
        Start Workflow
      </button>
    </div>
  );
}
```

**TanStack Router Pattern:**
```typescript
// view/src/routes/my-route.tsx
import { createRoute, type RootRoute } from "@tanstack/react-router";

function MyRouteComponent() {
  return (
    <div>
      <h1>My Route</h1>
      {/* Component content */}
    </div>
  );
}

// Export function that creates the route
export default (parentRoute: RootRoute) =>
  createRoute({
    path: "/my-route",
    component: MyRouteComponent,
    getParentRoute: () => parentRoute,
  });

// Add to main.tsx router tree:
import MyRoute from "./routes/my-route.tsx";

const routeTree = rootRoute.addChildren([
  indexRoute,
  MyRoute(rootRoute),
  // ... other routes
]);
```

**Navigation Best Practices:**

Use TanStack Router's type-safe navigation components and hooks for internal navigation:

```typescript
import { Link, useNavigate } from "@tanstack/react-router";

function NavigationExamples() {
  const navigate = useNavigate();

  const handleProgrammaticNavigation = () => {
    // Type-safe programmatic navigation
    navigate({ to: "/my-route" });
    
    // With search params
    navigate({ 
      to: "/my-route", 
      search: { filter: "active" } 
    });
    
    // With route params
    navigate({ 
      to: "/users/$userId", 
      params: { userId: "123" } 
    });
  };

  return (
    <div>
      {/* ✅ Use Link for internal navigation */}
      <Link to="/my-route">Go to My Route</Link>
      
      {/* ✅ Link with search params */}
      <Link to="/my-route" search={{ filter: "active" }}>
        Filtered Route
      </Link>
      
      {/* ✅ Link with route params */}
      <Link to="/users/$userId" params={{ userId: "123" }}>
        User Profile
      </Link>
      
      {/* ✅ External links use regular anchor tags */}
      <a href="https://external-site.com" target="_blank" rel="noopener noreferrer">
        External Link
      </a>
      
      {/* ✅ Programmatic navigation */}
      <button onClick={handleProgrammaticNavigation}>
        Navigate Programmatically
      </button>
    </div>
  );
}
```

**❌ Avoid using anchor tags for internal navigation:**
```typescript
// DON'T DO THIS for internal routes
<a href="/my-route">Internal Link</a>

// This loses type safety and doesn't work with TanStack Router's features
```

**Navigation Guidelines:**
- Use `<Link>` component for internal route navigation with full type safety
- Use `useNavigate()` hook for programmatic navigation (form submissions, button clicks, etc.)
- Only use `<a>` tags for external links (different domains, mailto:, tel:, etc.)
- TanStack Router provides compile-time route validation and autocompletion

## Development Best Practices

### When Adding New Tools:
1. Add tool definition in `server/main.ts`
2. Include in `withRuntime` tools array
3. Run `npm run gen` to update external integration types
4. Start server with `npm run dev` and copy the development URL from logs
5. Run `DECO_SELF_URL=<your-dev-url> npm run gen:self` to generate self-types
6. Create TanStack Query hooks in `view/src/hooks/` to wrap RPC calls
7. Use the hooks in components instead of calling `client.YOUR_TOOL()` directly

### When Adding New Workflows:
1. Create workflow in `server/main.ts`
2. Include in `withRuntime` workflows array
3. Run `npm run gen` to update external integration types
4. Start server with `npm run dev` and copy the development URL from logs
5. Run `DECO_SELF_URL=<your-dev-url> npm run gen:self` to generate self-types
6. Create TanStack Query mutation hooks in `view/src/hooks/` to wrap workflow calls
7. Use the hooks in components instead of calling `client.START_YOUR_WORKFLOW()` directly

### When Adding New Routes:
1. Create route component in `view/src/routes/`
2. Export a function that takes a parent route and returns `createRoute()`
3. Add route to router tree in `view/src/main.tsx`
4. Use TanStack Router's typesafe `createRoute` pattern

### When Adding UI Components:
1. Use shadcn CLI to add new components: `cd view && npx shadcn@latest add <component-name>`
2. Use Tailwind CSS classes for styling
3. Leverage shadcn/ui components in `view/src/components/ui/`
4. Use `clsx` and `tailwind-merge` for conditional classes
5. Use lucide-react icons for consistent iconography (already installed)

## Environment Setup

### Prerequisites:
- Node.js >=18.0.0
- npm >=8.0.0
- Deno >=2.0.0
- Deco CLI installed: `deno install -Ar -g -n deco jsr:@deco/cli`

### Initial Setup:
1. `deco login` - Authenticate with deco.chat
2. `npm install` - Install all dependencies
3. `npm run configure` - Configure the app with the desired name and select its workspace
4. `npm run dev` - Start development

## Integration with Deco Platform

### Adding External Integrations:
1. Go to deco.chat dashboard
2. Add integrations (APIs, databases, etc.)
3. Run `npm run gen` to get typed interfaces
4. Use typed clients in your tools/workflows

### Deployment:
- `npm run deploy` deploys to Cloudflare Workers
- App becomes available at public URL
- Can be used as MCP server by AI agents

## Common Patterns

### Error Handling:
```typescript
// In tools
execute: async ({ context }) => {
  const result = await someAsyncOperation(context);
  if (!result.ok) {
    throw new Error("...")
  }
  return result;
}
```

### Frontend State Management:
- Use `@tanstack/react-query` for server state management
- Prefer wrapping RPC client calls in TanStack Query hooks over direct calls in components
- Create custom hooks in `view/src/hooks/` for each tool/workflow:
  - Use `useQuery` for read operations (data fetching)
  - Use `useMutation` for write operations (tools/workflows that modify state)
- Use TanStack Router for typesafe navigation and routing state
- Use React hooks for component-local state

### TanStack Query Hook Patterns:

```typescript
// view/src/hooks/useTools.ts - Example comprehensive hook patterns

import { useQuery, useMutation, useQueryClient, useInfiniteQuery } from "@tanstack/react-query";
import { client } from "../lib/rpc";

// 1. Simple data fetching with useQuery
export const useGetData = (id: string) => {
  return useQuery({
    queryKey: ["data", id],
    queryFn: () => client.GET_DATA({ id }),
    enabled: !!id, // Only run when id is provided
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
  });
};

// 2. Mutation with optimistic updates and cache invalidation
export const useUpdateData = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (data: { id: string; value: string }) => 
      client.UPDATE_DATA(data),
    
    // Optimistic update
    onMutate: async (newData) => {
      await queryClient.cancelQueries({ queryKey: ["data", newData.id] });
      const previousData = queryClient.getQueryData(["data", newData.id]);
      queryClient.setQueryData(["data", newData.id], newData);
      return { previousData };
    },
    
    // Rollback on error
    onError: (err, newData, context) => {
      if (context?.previousData) {
        queryClient.setQueryData(["data", newData.id], context.previousData);
      }
    },
    
    // Refetch on success
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ queryKey: ["data", variables.id] });
    },
  });
};

// 3. Long-running workflow with status polling
export const useWorkflowWithPolling = () => {
  return useMutation({
    mutationFn: (input: { name: string }) => 
      client.START_LONG_WORKFLOW(input),
    
    onSuccess: (data) => {
      // Start polling for workflow status
      if (data.workflowId) {
        // You can trigger a separate useQuery to poll status
        // or use queryClient.refetchQueries to update related data
      }
    },
  });
};

// 4. Dependent queries - only run when previous data is available
export const useUserProfile = (userId: string) => {
  return useQuery({
    queryKey: ["userProfile", userId],
    queryFn: () => client.GET_USER_PROFILE({ userId }),
    enabled: !!userId,
  });
};

export const useUserPreferences = (userId: string) => {
  const { data: userProfile } = useUserProfile(userId);
  
  return useQuery({
    queryKey: ["userPreferences", userId],
    queryFn: () => client.GET_USER_PREFERENCES({ userId }),
    enabled: !!userProfile, // Only run after user profile loads
  });
};

// 5. Infinite query for paginated data
export const useInfiniteData = (filters: any) => {
  return useInfiniteQuery({
    queryKey: ["infiniteData", filters],
    queryFn: ({ pageParam = 0 }) => 
      client.GET_PAGINATED_DATA({ ...filters, page: pageParam }),
    getNextPageParam: (lastPage) => lastPage.nextPage,
    initialPageParam: 0,
  });
};
```

### Component Usage Examples:

```typescript
// ✅ CORRECT: Using TanStack Query hooks
function DataComponent({ id }: { id: string }) {
  const { data, isLoading, error } = useGetData(id);
  const updateMutation = useUpdateData();
  const workflowMutation = useWorkflowWithPolling();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h2>{data?.title}</h2>
      <button 
        onClick={() => updateMutation.mutate({ id, value: "new value" })}
        disabled={updateMutation.isPending}
      >
        {updateMutation.isPending ? "Updating..." : "Update"}
      </button>
      
      <button 
        onClick={() => workflowMutation.mutate({ name: "process" })}
        disabled={workflowMutation.isPending}
      >
        {workflowMutation.isPending ? "Processing..." : "Start Process"}
      </button>
    </div>
  );
}
```

### Styling:
- Tailwind CSS for utility-first styling
- shadcn/ui components for consistent design
- Use `cn()` utility for conditional classes

## Debugging Tips

- Server logs appear in terminal during `npm run dev`
- Use browser dev tools for frontend debugging

This template provides a complete full-stack development environment for building MCP servers with modern React frontends. Focus on adding your business logic in tools and workflows while leveraging the typed RPC communication between frontend and backend.
